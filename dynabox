#!/usr/bin/env bash

set -euo pipefail

usage() {
  echo "Usage: $0 <command> [options]"
  echo ""
  echo "Commands:"
  echo "  build                       Build glibc images."
  echo "  export                      Export built glibc from container to host."
  echo "  compile                     Compile with the specific architecture and glibc version."
  echo ""
  echo "Build Options:"
  echo "  --version <version>         Build the specific glibc version."
  echo "  --arch <arch>               x86_64, i686, or both"
  echo "  --tag <name:tag>            Optional image name (default: glibc:<GLIBC_VERSION>)"
  echo "  --proxy-port <port>         Optional proxy port, host IP auto-detected."
  echo ""
  echo "Export Options:"
  echo "  --version <version>         Export the specific glibc built binaries to /opt/glibc directory."
  echo "  --arch <arch>               x86_64, i686, or both"
  echo "  --tag <name:tag>            Optional image name (default: glibc:<GLIBC_VERSION>)"
  echo ""
  echo "Compile Options:"
  echo "  <file>                      <file> is C source code which would be compiled."
  echo "  -o, --output <file>         Place the output into <file>."
  echo "  -a, --arch <arch>           Target bits: 64 or 32 (default: host arch)."
  echo "  -v, --version <version>     Version of glibc you want to use to compile (default: system glibc)."
  exit 1
}

COMMAND="${1:-}"
if [[ -z "$COMMAND" ]]; then
  usage
fi
shift

IMAGE_TAG=""
PROXY_PORT=""

case "$COMMAND" in
build)
  GLIBC_VERSION=""
  ARCH=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --version)
      GLIBC_VERSION="${2:?Missing value for --version}"
      shift 2
      ;;
    --arch)
      ARCH="${2:?Missing value for --arch}"
      shift 2
      ;;
    --tag)
      IMAGE_TAG="${2:?Missing value for --tag}"
      shift 2
      ;;
    --proxy-port)
      PROXY_PORT="${2:?Missing value for --proxy-port}"
      shift 2
      ;;
    --help)
      usage
      ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
    esac
  done

  if [ -z "$GLIBC_VERSION" ]; then
    echo "Missing --version"
    usage
  fi

  if [ -z "$ARCH" ]; then
    echo "Missing --arch"
    usage
  fi

  if [ -z "$IMAGE_TAG" ]; then
    IMAGE_TAG="glibc:${GLIBC_VERSION}"
  fi

  TARGETS=()
  case "$ARCH" in
  x86_64) TARGETS+=(builder-x86_64) ;;
  i686) TARGETS+=(builder-i686) ;;
  both) TARGETS+=(builder-x86_64 builder-i686) ;;
  *)
    echo "Unsupported arch: $ARCH"
    usage
    ;;
  esac

  PROXY_ARGS=()
  if [ -n "${PROXY_PORT}" ]; then
    PROXY_IP=$(ip -4 route get 8.8.8.8 2>/dev/null | awk '{print $7; exit}')
    if [ -z "$PROXY_IP" ]; then
      PROXY_IP=$(hostname -i 2>/dev/null | awk '{print $1}')
    fi

    if [ -z "$PROXY_IP" ]; then
      echo "[-] Cannot detect host IP"
      exit 1
    fi

    PROXY_URL="http://${PROXY_IP}:${PROXY_PORT}"
    PROXY_ARGS=(
      --build-arg "http_proxy=$PROXY_URL"
      --build-arg "https_proxy=$PROXY_URL"
      --build-arg "HTTP_PROXY=$PROXY_URL"
      --build-arg "HTTPS_PROXY=$PROXY_URL"
      --build-arg "NO_PROXY=localhost,127.0.0.0/8"
    )
    echo "[*] Using proxy $PROXY_URL"
  fi

  for TARGET in "${TARGETS[@]}"; do
    echo "[*] Building target: $TARGET ..."
    docker build \
      "${PROXY_ARGS[@]}" \
      --build-arg "GLIBC_VERSION=${GLIBC_VERSION}" \
      --target "$TARGET" \
      -t "${IMAGE_TAG}-${TARGET}" \
      .
  done

  TMP_DF="$(mktemp --tmpdir Dockerfile.yield.XXXX)"
  trap 'rm -f "${TMP_DF:-}"' EXIT

  cat >"${TMP_DF}" <<EOF
FROM scratch
ARG GLIBC_VERSION
ENV GLIBC_VERSION=\${GLIBC_VERSION}
LABEL maintainer="CuB3y0nd <root@cubeyond.net>"
EOF

  for T in "${TARGETS[@]}"; do
    case "$T" in
    builder-x86_64)
      echo "COPY --from=${IMAGE_TAG}-${T} /opt/glibc/${GLIBC_VERSION}/64 /opt/glibc/${GLIBC_VERSION}/64" >>"${TMP_DF}"
      ;;
    builder-i686)
      echo "COPY --from=${IMAGE_TAG}-${T} /opt/glibc/${GLIBC_VERSION}/32 /opt/glibc/${GLIBC_VERSION}/32" >>"${TMP_DF}"
      ;;
    esac
  done

  echo "[*] Building final combined image: $IMAGE_TAG-$ARCH ..."
  docker build \
    --build-arg "GLIBC_VERSION=${GLIBC_VERSION}" \
    -f "${TMP_DF}" \
    -t "${IMAGE_TAG}-${ARCH}" \
    .

  rm -f "${TMP_DF}"

  for TARGET in "${TARGETS[@]}"; do
    echo "[*] Removing temp image: ${IMAGE_TAG}-${TARGET}"
    docker rmi -f "${IMAGE_TAG}-${TARGET}" >/dev/null 2>&1 || true
  done

  echo "[+] Final combined image built: ${IMAGE_TAG}-${ARCH}"
  ;;

export)
  GLIBC_VERSION=""
  ARCH=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --version)
      GLIBC_VERSION="${2:?Missing value for --version}"
      shift 2
      ;;
    --arch)
      ARCH="${2:?Missing value for --arch}"
      shift 2
      ;;
    --tag)
      IMAGE_TAG="${2:?Missing value for --tag}"
      shift 2
      ;;
    --help)
      usage
      ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
    esac
  done

  if [ -z "$GLIBC_VERSION" ]; then
    echo "Missing --version"
    usage
  fi

  if [ -z "$ARCH" ]; then
    echo "Missing --arch"
    usage
  fi

  if [ -z "$IMAGE_TAG" ]; then
    IMAGE_TAG="glibc:${GLIBC_VERSION}"
  fi

  HOST_ROOT="/opt/glibc"
  HOST_DIR="${HOST_ROOT}/${GLIBC_VERSION}"

  echo "[*] Exporting glibc-${GLIBC_VERSION} (${ARCH}) to ${HOST_DIR}"
  mkdir -p "${HOST_ROOT}"

  if ! docker image inspect "${IMAGE_TAG}-${ARCH}" >/dev/null 2>&1; then
    echo "[-] Image not found: ${IMAGE_TAG}-${ARCH}, please build it first."
    usage
  fi

  # Always pass a dummy command for scratch-based images. `docker create`
  # doesn't verify command existence unless container is started.
  CID=$(docker create "${IMAGE_TAG}-${ARCH}" /bin/true)

  case "$ARCH" in
  x86_64 | i686 | both)
    docker cp "${CID}:/opt/glibc/${GLIBC_VERSION}" "${HOST_ROOT}"
    ;;
  *)
    # This branch should never be hit because ARCH is validated earlier.
    echo "Unsupported arch in export: $ARCH"
    docker rm "${CID}" >/dev/null
    exit 1
    ;;
  esac

  docker rm "${CID}" >/dev/null

  echo "[+] Export completed to ${HOST_DIR}"
  ;;

compile)
  SRC=""
  OUT=""
  TARGET_BITS=""
  GLIBC_VER=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    -o | --output)
      OUT="${2:?Missing value for -o, --output}"
      shift 2
      ;;
    -a | --arch)
      TARGET_BITS="${2:?Missing value for -a, --arch (32 or 64)}"
      shift 2
      ;;
    -v | --version)
      GLIBC_VER="${2:?Missing value for -v, --version}"
      shift 2
      ;;
    --help)
      usage
      ;;
    -*)
      echo "Unknown option for compile: $1"
      usage
      ;;
    *)
      if [ -z "$SRC" ]; then
        SRC="$1"
      else
        echo "Unexpected positional argument: $1"
        usage
      fi
      shift
      ;;
    esac
  done

  if [ -z "$SRC" ]; then
    echo "Missing source file for compile"
    usage
  fi

  if [ -z "$OUT" ]; then
    # default output: source filename without extend name
    OUT="$(basename "$SRC")"
    OUT="${OUT%.c}"
  fi

  # determine target bits if not specified
  if [ -z "$TARGET_BITS" ]; then
    HOST_ARCH="$(uname -m)"
    case "$HOST_ARCH" in
    x86_64 | amd64) TARGET_BITS="64" ;;
    i386 | i486 | i586 | i686) TARGET_BITS="32" ;;
    *)
      echo "Cannot determine host arch ($HOST_ARCH). Please pass -a 32|64."
      exit 1
      ;;
    esac
  fi

  if [[ "$TARGET_BITS" != "32" && "$TARGET_BITS" != "64" ]]; then
    echo "Invalid -a, --arch value: ${TARGET_BITS}. Use 32 or 64."
    exit 1
  fi

  # find glibc path if requested
  if [ -n "${GLIBC_VER:-}" ]; then
    GLIBC_PATH="/opt/glibc/${GLIBC_VER}/${TARGET_BITS}"
    if [ ! -d "$GLIBC_PATH" ]; then
      echo "Requested glibc path not found: ${GLIBC_PATH}, please build it first."
      usage
    fi
  else
    GLIBC_PATH=""
  fi

  echo "[*] Compiling $SRC -> $OUT (bits=${TARGET_BITS}, glibc=${GLIBC_VER:-system})"

  GCC_CMD=(gcc -Wall "$SRC" -o "$OUT")
  if [ "$TARGET_BITS" = "32" ]; then
    GCC_CMD+=(-m32)
  fi

  if [ -n "$GLIBC_PATH" ]; then
    if [ "$TARGET_BITS" = "64" ]; then
      DYN_LINKER="${GLIBC_PATH}/lib/ld-linux-x86-64.so.2"
    else
      DYN_LINKER="${GLIBC_PATH}/lib/ld-linux.so.2"
    fi

    GCC_CMD+=(-B "${GLIBC_PATH}/lib")
    GCC_CMD+=(-L "${GLIBC_PATH}/lib")
    GCC_CMD+=(-I "${GLIBC_PATH}/include")
    GCC_CMD+=("-Wl,--rpath=${GLIBC_PATH}/lib")
    GCC_CMD+=("-Wl,--dynamic-linker=${DYN_LINKER}")
  fi

  echo "[+] Running: ${GCC_CMD[*]}"
  "${GCC_CMD[@]}"

  echo "[+] Compile finished: ./${OUT}"
  ;;

*)
  echo "Unknown command: $COMMAND"
  usage
  ;;
esac
